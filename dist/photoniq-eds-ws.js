/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PhotoniqEdsWs"] = factory();
	else
		root["PhotoniqEdsWs"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/connection.ts":
/*!***************************!*\
  !*** ./src/connection.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = exports.EDSEventType = void 0;\nconst query_set_1 = __webpack_require__(/*! ./query-set */ \"./src/query-set.ts\");\nconst PHOTONIQ_ES = \"x-photoniq-es\";\n/**\n * List of event types generated by EDS driver\n*/\nvar EDSEventType;\n(function (EDSEventType) {\n    EDSEventType[\"Open\"] = \"open\";\n    EDSEventType[\"Close\"] = \"close\";\n    EDSEventType[\"ConnectionId\"] = \"connection-id\";\n    EDSEventType[\"ServerQueryError\"] = \"server-query-error\";\n    EDSEventType[\"ServerGlobalError\"] = \"server-global-error\";\n    EDSEventType[\"ClientQueryError\"] = \"client-query-error\";\n    EDSEventType[\"ClientGlobalError\"] = \"client-global-error\";\n    EDSEventType[\"Message\"] = \"message\";\n})(EDSEventType || (exports.EDSEventType = EDSEventType = {}));\n/**\n * The main class manages connection and queries.\n */\nclass Connection {\n    constructor(config, globalListener) {\n        this.queriesToQuerySetsAndCallbacks = new Map();\n        this.waitingMessages = [];\n        this.config = config;\n        this.globalListener = globalListener;\n    }\n    /**\n     * Connect to web socket\n     */\n    connect() {\n        const url = `wss://${this.config.host}/api/es/v1/subscribe?type=collection` +\n            `&x-customer-id=${this.config.customerId}` +\n            `&apiKey=${this.config.apiKey}` +\n            `&fabric=${this.config.fabric}` +\n            `&filters=%7B%22action%22%3A%22remove%22%2C%22queries%22%3A%5B%22SELECT%20%2A%20FROM%20fake%22%5D%7D`;\n        this.ws = new WebSocket(url);\n        let self = this;\n        this.ws.addEventListener('open', function (event) {\n            var _a;\n            for (let msg of self.waitingMessages) {\n                (_a = self.ws) === null || _a === void 0 ? void 0 : _a.send(msg);\n            }\n            self.waitingMessages = [];\n            const edsEvent = {\n                type: EDSEventType.Open,\n                connection: self,\n                data: event\n            };\n            self.handleGlobalListener(edsEvent);\n            self.updatePingInterval();\n        });\n        this.ws.addEventListener('message', function (event) {\n            let msg = event.data;\n            if (self.id) {\n                let data = JSON.parse(msg);\n                if (!data.error) {\n                    for (let query in data) {\n                        let querySetsAndCallbacksOnce = self.queriesToQuerySetsAndCallbacks.get(query);\n                        if (querySetsAndCallbacksOnce) {\n                            let dataForQuery = data[query];\n                            if (querySetsAndCallbacksOnce.initial && querySetsAndCallbacksOnce.count === 0) {\n                                for (let i = 0; i < dataForQuery.length; i++) {\n                                    dataForQuery[i] = self.convertInitialData(dataForQuery[i]);\n                                }\n                            }\n                            else {\n                                dataForQuery = [dataForQuery];\n                            }\n                            querySetsAndCallbacksOnce.count += 1;\n                            for (const [qs, callbacks] of querySetsAndCallbacksOnce.qsCb) {\n                                for (let callback of callbacks) {\n                                    //console.log(`Execute callback for query: ${query}`)\n                                    try {\n                                        let edsEvent = {\n                                            type: EDSEventType.Message,\n                                            connection: self,\n                                            data: dataForQuery,\n                                            query: query,\n                                            count: querySetsAndCallbacksOnce.count,\n                                            retrieve: querySetsAndCallbacksOnce.initial,\n                                        };\n                                        callback(edsEvent);\n                                        self.handleGlobalListener(edsEvent);\n                                    }\n                                    catch (e) {\n                                        let msg = `Error while handling data for query: ${query}`;\n                                        const edsEvent = {\n                                            type: EDSEventType.ClientQueryError,\n                                            connection: self,\n                                            data: e,\n                                            message: msg,\n                                            query: query\n                                        };\n                                        self.handleErrorListenerForMap(querySetsAndCallbacksOnce, query, edsEvent);\n                                        self.handleGlobalListener(edsEvent);\n                                    }\n                                }\n                            }\n                            if (querySetsAndCallbacksOnce.once) {\n                                self.queriesToQuerySetsAndCallbacks.delete(query);\n                                const msg = JSON.stringify({\n                                    \"action\": \"remove\",\n                                    \"queries\": [query]\n                                });\n                                self.send(msg);\n                                //console.log(`Once query deleted from queriesToQuerySetsAndCallbacks: ${query}`);\n                            }\n                        }\n                    }\n                }\n                else {\n                    let msg = data.error;\n                    const queryErrorPrefix = \"Error parsing SQL query:\";\n                    if (msg.startsWith(queryErrorPrefix)) {\n                        let query = msg.substring(queryErrorPrefix.length, msg.indexOf(\"ERROR\")).trim();\n                        const edsEvent = {\n                            type: EDSEventType.ServerQueryError,\n                            connection: self,\n                            data: undefined,\n                            code: data.code,\n                            message: msg,\n                            query: query\n                        };\n                        let querySetsAndCallbacksOnce = self.queriesToQuerySetsAndCallbacks.get(query);\n                        if (querySetsAndCallbacksOnce) {\n                            self.handleErrorListenerForMap(querySetsAndCallbacksOnce, query, edsEvent);\n                        }\n                        self.handleGlobalListener(edsEvent);\n                    }\n                    else {\n                        const edsEvent = {\n                            type: EDSEventType.ServerGlobalError,\n                            connection: self,\n                            data: undefined,\n                            code: data.code,\n                            message: msg\n                        };\n                        self.handleGlobalListener(edsEvent);\n                    }\n                }\n            }\n            else {\n                // retrieve connection id\n                const i = msg.indexOf(PHOTONIQ_ES);\n                if (i > -1) {\n                    const start = i + PHOTONIQ_ES.length + 1;\n                    const end = msg.indexOf(\"\\n\", start);\n                    self.id = parseInt(msg.substring(start, end).trim());\n                    const edsEvent = {\n                        type: EDSEventType.ConnectionId,\n                        connection: self,\n                        data: self.id\n                    };\n                    self.handleGlobalListener(edsEvent);\n                }\n            }\n        });\n        this.ws.addEventListener('close', function (event) {\n            if (self.pingIntervalId) {\n                clearInterval(self.pingIntervalId);\n            }\n            const edsEvent = {\n                type: EDSEventType.Close,\n                connection: self,\n                data: event\n            };\n            self.handleGlobalListener(edsEvent);\n        });\n        this.ws.addEventListener('error', function (event) {\n            const edsEvent = {\n                type: EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event,\n                message: \"Client error\",\n            };\n            self.handleGlobalListener(edsEvent);\n        });\n    }\n    /**\n     * Send data directly to web socket\n     */\n    send(msg) {\n        var _a;\n        if (this.isConnected()) {\n            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(msg);\n            this.updatePingInterval();\n        }\n        else {\n            this.waitingMessages.push(msg);\n        }\n    }\n    querySet() {\n        return new query_set_1.QuerySet(this, this.queriesToQuerySetsAndCallbacks);\n    }\n    /**\n     * Disconnect from web socket\n     */\n    disconnect() {\n        var _a;\n        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    /**\n     * Get configuration of the connection\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get connection id\n     */\n    getId() {\n        return this.id;\n    }\n    /**\n     * Check weather it connected\n     */\n    isConnected() {\n        var _a;\n        return ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN;\n    }\n    convertInitialData(sqlData) {\n        for (let sqlParameter in sqlData) {\n            let path = sqlParameter.split('.');\n            if (path.length <= 1) {\n                continue;\n            }\n            let value = sqlData;\n            for (let i = 0; i < path.length; i++) {\n                if (value[path[i]] === undefined) {\n                    value[path[i]] = {};\n                }\n                // if not last\n                if (i < path.length - 1) {\n                    value = value[path[i]];\n                }\n            }\n            value[path[path.length - 1]] = sqlData[sqlParameter];\n            delete sqlData[sqlParameter];\n        }\n        return sqlData;\n    }\n    handleGlobalListener(edsEvent) {\n        var _a;\n        try {\n            (_a = this.globalListener) === null || _a === void 0 ? void 0 : _a.call(this, edsEvent);\n        }\n        catch (e) {\n            console.warn(`Error while handling global error listener`, e);\n        }\n    }\n    handleErrorListenerForMap(querySetsAndCallbacksOnce, query, edsEvent) {\n        for (const [qs, callbacks] of querySetsAndCallbacksOnce.qsErrCb) {\n            for (let callback of callbacks) {\n                try {\n                    callback(edsEvent);\n                }\n                catch (e) {\n                    console.warn(`Error while handling error listener for query: ${query}`, e);\n                }\n            }\n        }\n    }\n    updatePingInterval() {\n        var _a;\n        if (this.pingIntervalId !== undefined) {\n            clearInterval(this.pingIntervalId);\n        }\n        let self = this;\n        this.pingIntervalId = setInterval(() => {\n            var _a;\n            (_a = self.ws) === null || _a === void 0 ? void 0 : _a.send(\"{1}\");\n        }, (_a = self.config.pingSeconds) !== null && _a !== void 0 ? _a : 29 * 1000);\n    }\n}\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/connection.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\nconst connection_1 = __webpack_require__(/*! ./connection */ \"./src/connection.ts\");\n/**\n * Establish connection to PhotonIQ EDS server.\n * @param config configuration for the connection\n * @param globalListener listen all `EDSEvent` events.\n * @module connection\n */\nfunction connect(config, globalListener) {\n    let connection = new connection_1.Connection(config, globalListener);\n    connection.connect();\n    return connection;\n}\nexports.connect = connect;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/index.ts?");

/***/ }),

/***/ "./src/query-batch.ts":
/*!****************************!*\
  !*** ./src/query-batch.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueryBatch = void 0;\n/**\n * @module QueryBatch\n * Joins all querues togather and sends as a batch\n */\nclass QueryBatch {\n    /** @ignore */\n    constructor(retrieveList, retrieveAndSubscribeList, subscribeList, unsubscribeList, addCallbackToQueries, removeCallbacksForQuery, queriesToQuerySetsAndCallbacks, querySet, connection) {\n        this.subscribeQueries = [];\n        this.retrieveAndSubscribeQueries = [];\n        this.retrieveQueries = [];\n        this.unsubscribeQueries = [];\n        this.retrieveList = retrieveList;\n        this.retrieveAndSubscribeList = retrieveAndSubscribeList;\n        this.subscribeList = subscribeList;\n        this.unsubscribeList = unsubscribeList;\n        this.addCallbackToQueries = addCallbackToQueries;\n        this.removeCallbacksForQuery = removeCallbacksForQuery;\n        this.queriesToQuerySetsAndCallbacks = queriesToQuerySetsAndCallbacks;\n        this.querySet = querySet;\n        this.connection = connection;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        this.subscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieveAndSubscribe(query, listener, errorListener) {\n        this.retrieveAndSubscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieve(query, listener, errorListener) {\n        this.retrieveQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        this.unsubscribeQueries.push(query);\n        return this;\n    }\n    /**\n     * Assemble list of queries to batch request\n     */\n    assemble() {\n        this.retrieveList(this.retrieveQueries, this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this.querySet, this.connection);\n        this.retrieveAndSubscribeList(this.retrieveAndSubscribeQueries, this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this.querySet, this.connection);\n        this.subscribeList(this.subscribeQueries, this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this.querySet, this.connection);\n        this.unsubscribeList(this.unsubscribeQueries, this.removeCallbacksForQuery, this.queriesToQuerySetsAndCallbacks, this.querySet, this.connection);\n    }\n}\nexports.QueryBatch = QueryBatch;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-batch.ts?");

/***/ }),

/***/ "./src/query-set.ts":
/*!**************************!*\
  !*** ./src/query-set.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuerySet = void 0;\nconst query_batch_1 = __webpack_require__(/*! ./query-batch */ \"./src/query-batch.ts\");\n/**\n * Manages queries as a set\n */\nclass QuerySet {\n    /** @ignore */\n    constructor(connection, queriesToQuerySetsAndCallbacks) {\n        this.connection = connection;\n        this.queriesToQuerySetsAndCallbacks = queriesToQuerySetsAndCallbacks;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        this.subscribeList([{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }], this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    subscribeList(queries, addCallbackToQueries, queriesToQuerySetsAndCallbacks, querySet, connection) {\n        let queriesToBeAdded = [];\n        for (const query of queries) {\n            let toAdd = addCallbackToQueries([query.query], query.listener, query.errorListener, false, false, queriesToQuerySetsAndCallbacks, querySet);\n            queriesToBeAdded.push(...toAdd);\n        }\n        if (queriesToBeAdded.length) {\n            const msg = JSON.stringify({\n                \"action\": \"add\",\n                \"queries\": queriesToBeAdded\n            });\n            connection.send(msg);\n        }\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieveAndSubscribe(query, listener, errorListener) {\n        this.retrieveAndSubscribeList([{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }], this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    retrieveAndSubscribeList(queries, addCallbackToQueries, queriesToQuerySetsAndCallbacks, querySet, connection) {\n        let queriesToBeAdded = [];\n        for (const query of queries) {\n            let toAdd = addCallbackToQueries([query.query], query.listener, query.errorListener, false, true, queriesToQuerySetsAndCallbacks, querySet);\n            queriesToBeAdded.push(...toAdd);\n        }\n        if (queriesToBeAdded.length) {\n            const msg = JSON.stringify({\n                \"action\": \"add\",\n                \"initialData\": \"TRUE\",\n                \"queries\": queriesToBeAdded\n            });\n            connection.send(msg);\n        }\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of Connection.EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieve(query, listener, errorListener) {\n        this.retrieveList([{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }], this.addCallbackToQueries, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    retrieveList(queries, addCallbackToQueries, queriesToQuerySetsAndCallbacks, querySet, connection) {\n        let queriesToBeAdded = [];\n        for (const query of queries) {\n            let toAdd = addCallbackToQueries([query.query], query.listener, query.errorListener, true, true, queriesToQuerySetsAndCallbacks, querySet);\n            queriesToBeAdded.push(...toAdd);\n        }\n        if (queriesToBeAdded.length) {\n            const msg = JSON.stringify({\n                \"action\": \"add\",\n                \"once\": \"TRUE\",\n                \"initialData\": \"TRUE\",\n                \"queries\": queriesToBeAdded\n            });\n            connection.send(msg);\n        }\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        this.unsubscribeList([query], this.removeCallbacksForQuery, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    unsubscribeList(queries, removeCallbacksForQuery, queriesToQuerySetsAndCallbacks, querySet, connection) {\n        let queriesToBeRemoved = removeCallbacksForQuery(queries, queriesToQuerySetsAndCallbacks, querySet);\n        if (queriesToBeRemoved.length) {\n            const msg = JSON.stringify({\n                \"action\": \"remove\",\n                \"queries\": queriesToBeRemoved\n            });\n            connection.send(msg);\n        }\n    }\n    /**\n     * Unsubscribe from all query in the QuerySet.\n     */\n    unsubscribeAll() {\n        let queries = Array.from(this.queriesToQuerySetsAndCallbacks.keys());\n        this.unsubscribeList(queries, this.removeCallbacksForQuery, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    /**\n     * Create QueryBatch instance to join all queries in one request and assemble at the end.\n     */\n    batch() {\n        return new query_batch_1.QueryBatch(this.retrieveList, this.retrieveAndSubscribeList, this.subscribeList, this.unsubscribeList, this.addCallbackToQueries, this.removeCallbacksForQuery, this.queriesToQuerySetsAndCallbacks, this, this.connection);\n    }\n    /**\n     * Add query and callback to map which uses for incoming messages in onMessage function\n     *\n     * @param queries - list of queries to be listened\n     * @param callback - callback function with the next arguments: `query`, `data`\n     * @param errorCallback - error callback function\n     * @param once - once retrieve data for the query\n     * @param initial - retrieve initial data for the query\n     * @param queriesToQuerySetsAndCallbacks\n     * @param querySet\n     * @returns list of queries were added. Not all queries are new. Some of them can be reused.\n     *\n     */\n    addCallbackToQueries(queries, callback, errorCallback, once, initial, queriesToQuerySetsAndCallbacks, querySet) {\n        let queriesToBeAdded = [];\n        for (let query of queries) {\n            let querySetsAndCallbacksOnce = queriesToQuerySetsAndCallbacks.get(query);\n            if (!querySetsAndCallbacksOnce) {\n                querySetsAndCallbacksOnce = { qsCb: new Map(), qsErrCb: new Map(), once: false, initial: false, count: 0 };\n            }\n            else if (querySetsAndCallbacksOnce.once !== once) {\n                //console.log(`Query already exists in queriesToQuerySetsAndCallbacks: ${query}`);\n                return queriesToBeAdded;\n            }\n            let newQuery = querySetsAndCallbacksOnce.qsCb.size === 0 || querySetsAndCallbacksOnce.once !== once;\n            if (newQuery) {\n                querySetsAndCallbacksOnce.once = once;\n                querySetsAndCallbacksOnce.count = 0;\n                querySetsAndCallbacksOnce.initial = initial;\n                queriesToBeAdded.push(query);\n                //console.log(`Added query in queriesToQuerySetsAndCallbacks: ${query}`);\n            }\n            let callbacks = querySetsAndCallbacksOnce.qsCb.get(querySet);\n            callbacks !== null && callbacks !== void 0 ? callbacks : (callbacks = []);\n            callbacks.push(callback);\n            querySetsAndCallbacksOnce.qsCb.set(querySet, callbacks);\n            if (errorCallback) {\n                let errorCallbacks = querySetsAndCallbacksOnce.qsErrCb.get(querySet);\n                errorCallbacks !== null && errorCallbacks !== void 0 ? errorCallbacks : (errorCallbacks = []);\n                errorCallbacks.push(errorCallback);\n                querySetsAndCallbacksOnce.qsErrCb.set(querySet, errorCallbacks);\n            }\n            queriesToQuerySetsAndCallbacks.set(query, querySetsAndCallbacksOnce);\n        }\n        return queriesToBeAdded;\n    }\n    removeCallbacksForQuery(queries, queriesToQuerySetsAndCallbacks, querySet) {\n        let queriesToBeRemoved = [];\n        for (let query of queries) {\n            let querySetsAndCallbacksOnce = queriesToQuerySetsAndCallbacks.get(query);\n            if (querySetsAndCallbacksOnce) {\n                querySetsAndCallbacksOnce.qsCb.delete(querySet);\n                querySetsAndCallbacksOnce.qsErrCb.delete(querySet);\n                if (querySetsAndCallbacksOnce.qsCb.size === 0) {\n                    queriesToQuerySetsAndCallbacks.delete(query);\n                    //console.log(`Deleted query from queriesToQuerySetsAndCallbacks: ${query}`);\n                    queriesToBeRemoved.push(query);\n                }\n            }\n        }\n        return queriesToBeRemoved;\n    }\n}\nexports.QuerySet = QuerySet;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-set.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});