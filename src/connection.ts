/**
 * Copyright (C) Macrometa, Inc - All Rights Reserved
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Macrometa, Inc <product@macrometa.com>, May 2024
 */

import { QuerySet } from "./query-set";

const PHOTONIQ_ES: string = "x-photoniq-es";

/**
 * Configure connection
 * @param host host of the connection
 * @param customerId customer id credentails
 * @param apiKey ApiKey credentails
 * @param fabric fabric to be used. Default is `_system`
 * @param pingSeconds seconds to send ping-pong messages for the server. Default is `29`  
 */
export type Config = {
    host: string;
    customerId: string;
    apiKey: string;
    fabric?: string;
    pingSeconds?: number
};

/**
 * List of event types generated by EDS driver
*/
export enum EDSEventType {
    Open = "open",
    Close = "close",
    ConnectionId = "connection-id",
    ServerQueryError = "server-query-error",
    ServerGlobalError = "server-global-error",
    ClientQueryError = "client-query-error",
    ClientGlobalError = "client-global-error",
    Message = "message"
}

/**
 * @param type type of event
 * @param connection connection instance which participated in event
 * @param data result of event
 */
export type EDSEvent = {
    type: EDSEventType;
    connection: Connection;
    data: any;
};

/**
 * @param code returns code or the error. Exists only for server responses
 * @param message error message
 * @param query error belongs to query in case if the error is not global
 */
export type EDSEventError = {
    code?: number;
    message: string;
    query?: string;
};

/**
 * @param query query of the event
 * @param count number of message returned by the subscribed query
 * @param retrieve return true if it is an intial data
 */
export type EDSEventMessage = {
    query: string;
    count: number;
    retrieve: boolean;
};

/**
 * The main class manages connection and queries.
 */
export class Connection {
    private config: Config;
    private ws: WebSocket | undefined;
    private id: number | undefined;
    private queriesToQuerySetsAndCallbacks: Map<any,any> = new Map();
    private pingIntervalId: number | undefined;
    private globalListener: (type: EDSEvent) => void;
    private waitingMessages: string[] = [];
    
    constructor(config: Config, globalListener: (event: EDSEvent) => void) {
        this.config = config;
        this.globalListener = globalListener;
    }
    
    /**
     * Connect to web socket
     */
    public connect(): void {
        const url: string = `wss://${this.config.host}/api/es/v1/subscribe?type=collection` +
            `&x-customer-id=${this.config.customerId}` +
            `&apiKey=${this.config.apiKey}` +
            `&fabric=${this.config.fabric}` +
            `&filters=%7B%22action%22%3A%22remove%22%2C%22queries%22%3A%5B%22SELECT%20%2A%20FROM%20fake%22%5D%7D`
        this.ws = new WebSocket(url);
        let self = this;
        this.ws.addEventListener('open', function(event) {
            for (let msg of self.waitingMessages) {
                self.ws?.send(msg);
            }
            self.waitingMessages = [];
            const edsEvent: EDSEvent = {
                type: EDSEventType.Open,
                connection: self,
                data: event
            };
            self.handleGlobalListener(edsEvent);
            self.updatePingInterval();
        });
    
        this.ws.addEventListener('message', function(event) {
            let msg = event.data;
            if (self.id) {
                let data = JSON.parse(msg);
                if (!data.error) {
                    for (let query in data) {
                        let querySetsAndCallbacksOnce = self.queriesToQuerySetsAndCallbacks.get(query);
                        if (querySetsAndCallbacksOnce) {
                            let dataForQuery = data[query];
                            if (querySetsAndCallbacksOnce.initial && querySetsAndCallbacksOnce.count === 0) {
                                for (let i = 0; i < dataForQuery.length; i++) {
                                    dataForQuery[i] = self.convertInitialData(dataForQuery[i]);
                                }
                            } else {
                                dataForQuery = [dataForQuery];
                            }
                            querySetsAndCallbacksOnce.count += 1;
                            for (const [qs, callbacks] of querySetsAndCallbacksOnce.qsCb) {
                                for (let callback of callbacks) {
                                    //console.log(`Execute callback for query: ${query}`)
                                    try {
                                        let edsEvent: EDSEvent & EDSEventMessage = {
                                            type: EDSEventType.Message,
                                            connection: self,
                                            data: dataForQuery,
                                            query: query,
                                            count: querySetsAndCallbacksOnce.count,
                                            retrieve: querySetsAndCallbacksOnce.initial,
                                        }
                                        callback(edsEvent);
                                        self.handleGlobalListener(edsEvent);
                                    } catch (e) {
                                        let msg = `Error while handling data for query: ${query}`;
                                        const edsEvent: EDSEvent & EDSEventError = {
                                            type: EDSEventType.ClientQueryError,
                                            connection: self,
                                            data: e,
                                            message: msg,
                                            query: query
                                        };
                                        self.handleErrorListenerForMap(querySetsAndCallbacksOnce, query, edsEvent);
                                        self.handleGlobalListener(edsEvent);
                                    }
                                }
                            }
                            if (querySetsAndCallbacksOnce.once) {
                                self.queriesToQuerySetsAndCallbacks.delete(query);
                                const msg = JSON.stringify({
                                    "action": "remove",
                                    "queries": [query]
                                    });
                                self.send(msg);
                                //console.log(`Once query deleted from queriesToQuerySetsAndCallbacks: ${query}`);
                            }
                        }
                    }
                } else {
                    let msg = data.error;
                    const queryErrorPrefix: string = "Error parsing SQL query:";
                    if (msg.startsWith(queryErrorPrefix)) {
                        let query = msg.substring(queryErrorPrefix.length, msg.indexOf("ERROR")).trim();
                        const edsEvent: EDSEvent & EDSEventError = {
                            type: EDSEventType.ServerQueryError,
                            connection: self,
                            data: undefined,
                            code: data.code,
                            message: msg,
                            query: query
                        };
                        
                        let querySetsAndCallbacksOnce = self.queriesToQuerySetsAndCallbacks.get(query);
                        if (querySetsAndCallbacksOnce) {
                            self.handleErrorListenerForMap(querySetsAndCallbacksOnce, query, edsEvent);
                        }
                        self.handleGlobalListener(edsEvent);
                    } else {
                        const edsEvent: EDSEvent & EDSEventError = {
                            type: EDSEventType.ServerGlobalError,
                            connection: self,
                            data: undefined,
                            code: data.code,
                            message: msg
                        };
                        self.handleGlobalListener(edsEvent);
                    }
                }
            } else {
                // retrieve connection id
                const i = msg.indexOf(PHOTONIQ_ES);
                if (i > -1) {
                    const start = i + PHOTONIQ_ES.length + 1;
                    const end = msg.indexOf("\n", start);
                    self.id = parseInt(msg.substring(start, end).trim());
                    const edsEvent: EDSEvent = {
                        type: EDSEventType.ConnectionId,
                        connection: self,
                        data: self.id
                    };
                    self.handleGlobalListener(edsEvent);
                }
            }
        });
    
        this.ws.addEventListener('close', function(event) {
            if (self.pingIntervalId){
                clearInterval(self.pingIntervalId);
            }
            const edsEvent: EDSEvent = {
                type: EDSEventType.Close,
                connection: self,
                data: event 
                };
            self.handleGlobalListener(edsEvent);
        });
    
        this.ws.addEventListener('error', function(event) {
            const edsEvent: EDSEvent & EDSEventError = {
                type: EDSEventType.ClientGlobalError,
                connection: self,
                data: event,
                message: "Client error",
                };
            self.handleGlobalListener(edsEvent);
        });
    }
    
    /**
     * Send data directly to web socket
     */
    public send(msg: string): void {
        if (this.isConnected()) {
            this.ws?.send(msg);
            this.updatePingInterval();
        } else {
            this.waitingMessages.push(msg);
        }
    }
    
    public querySet(): QuerySet {
        return new QuerySet(this, this.queriesToQuerySetsAndCallbacks);
    }
    
    /**
     * Disconnect from web socket
     */
    public disconnect(): void {
       this.ws?.close();
    }
    
    /**
     * Get configuration of the connection
     */
    public getConfig(): Config {
        return this.config;
    }
    
    /**
     * Get connection id
     */
    public getId(): number | undefined {
        return this.id;
    }
    
    /**
     * Check weather it connected
     */
    public isConnected(): boolean {
        return this.ws?.readyState === WebSocket.OPEN;
    }
    
    private convertInitialData(sqlData: any) {
        for (let sqlParameter in sqlData) {
            let path = sqlParameter.split('.');
            if (path.length <= 1) {
                continue;
            }
            let value = sqlData;
            for (let i = 0; i < path.length; i++) {
                if (value[path[i]] === undefined) {
                    value[path[i]] = {};
                }
                // if not last
                if (i < path.length - 1) {
                    value = value[path[i]];
                }
            }
            value[path[path.length - 1]] = sqlData[sqlParameter];
            delete sqlData[sqlParameter];
        }
        return sqlData;
    }
    
    private handleGlobalListener(edsEvent: EDSEvent): void {
        try {
            this.globalListener?.(edsEvent);
        } catch (e) {
            console.warn(`Error while handling global error listener`, e);
        }
    }
    
    private handleErrorListenerForMap(querySetsAndCallbacksOnce: any, query: string, edsEvent: EDSEvent): void {
        for (const [qs, callbacks] of querySetsAndCallbacksOnce.qsErrCb) {
            for (let callback of callbacks) {
                try {
                    callback(edsEvent);
                } catch (e) {
                    console.warn(`Error while handling error listener for query: ${query}`, e)
                }
            }
        }
    }
    
    private updatePingInterval() {
        if (this.pingIntervalId !== undefined) {
            clearInterval(this.pingIntervalId);
        }
        let self = this;
        this.pingIntervalId = setInterval(() => {
            self.ws?.send("{1}");
        }, self.config.pingSeconds ?? 29 * 1000);
    }
}


